// Import from `core` instead of from `std` since we are in no-std mode
use core::result::Result;

// Import heap related library from `alloc`
// https://doc.rust-lang.org/alloc/index.html
//use alloc::{vec, vec::Vec};

// Import CKB syscalls and structures
// https://nervosnetwork.github.io/ckb-std/riscv64imac-unknown-none-elf/doc/ckb_std/index.html
/*use ckb_std::{
    debug,
    high_level::{load_script, load_tx_hash},
    ckb_types::{bytes::Bytes, prelude::*},
};*/

use crate::error::Error;
use sparse_merkle_tree::{SMTBuilder, SMT, H256};

fn _test_verify() -> Result<(), Error> {
    let key = H256::from([
        0x38, 0x1d, 0xc5, 0x39, 0x1d, 0xab, 0x09, 0x9d,
        0xa5, 0xe2, 0x8a, 0xcd, 0x1a, 0xd8, 0x59, 0xa0,
        0x51, 0xcf, 0x18, 0xac, 0xe8, 0x04, 0xd0, 0x37,
        0xf1, 0x28, 0x19, 0xc6, 0xfb, 0xc0, 0xe1, 0x8b]);
    let val = H256::from([
        0x91,0x58,0xce,0x9b,0x0e,0x11,0xdd,0x15,
        0x0b,0xa2,0xae,0x5d,0x55,0xc1,0xdb,0x04,
        0xb1,0xc5,0x98,0x6e,0xc6,0x26,0xf2,0xe3,
        0x8a,0x93,0xfe,0x8a,0xd0,0xb2,0x92,0x3b]);
    let root_hash = H256::from([
        0xeb, 0xe0, 0xfa, 0xb3, 0x76, 0xcd, 0x80, 0x2d,
        0x36, 0x4e, 0xeb, 0x44, 0xaf, 0x20, 0xc6, 0x7a,
        0x74, 0xd6, 0x18, 0x3a, 0x33, 0x92, 0x8f, 0xea,
        0xd1, 0x63, 0x12, 0x0e, 0xf1, 0x2e, 0x6e, 0x06]);
    let proof: [u8; 69] = [
        0x4c, 0x4f, 0xff, 0x51, 0xff, 0x32, 0x2d, 0xe8,
        0xa8, 0x9f, 0xe5, 0x89, 0x98, 0x7f, 0x97, 0x22,
        0x0c, 0xfc, 0xb6, 0x82, 0x0b, 0xd7, 0x98, 0xb3,
        0x1a, 0x0b, 0x56, 0xff, 0xea, 0x22, 0x10, 0x93,
        0xd3, 0x5f, 0x90, 0x9e, 0x58, 0x0b, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00];

    let _builder = SMTBuilder::new();
    let _builder = _builder.insert(&key, &val).unwrap();

    let smt: SMT = _builder.build().unwrap();
    if smt.verify(&root_hash, &proof).is_err() {
        return Err(Error::VerifyError);
    }

    Ok(())
}

fn _test_verify_fail() -> Result<(), Error> {
    let key = H256::from([
        0x18, 0x1d, 0xc5, 0x39, 0x1d, 0xab, 0x09, 0x9d,
        0xa5, 0xe2, 0x8a, 0xcd, 0x1a, 0xd8, 0x59, 0xa0,
        0x51, 0xcf, 0x18, 0xac, 0xe8, 0x04, 0xd0, 0x37,
        0xf1, 0x28, 0x19, 0xc6, 0xfb, 0xc0, 0xe1, 0x8b]);
    let val = H256::from([
        0x91,0x58,0xce,0x9b,0x0e,0x11,0xdd,0x15,
        0x0b,0xa2,0xae,0x5d,0x55,0xc1,0xdb,0x04,
        0xb1,0xc5,0x98,0x6e,0xc6,0x26,0xf2,0xe3,
        0x8a,0x93,0xfe,0x8a,0xd0,0xb2,0x92,0x3b]);
    let root_hash = H256::from([
        0xeb, 0xe0, 0xfa, 0xb3, 0x76, 0xcd, 0x80, 0x2d,
        0x36, 0x4e, 0xeb, 0x44, 0xaf, 0x20, 0xc6, 0x7a,
        0x74, 0xd6, 0x18, 0x3a, 0x33, 0x92, 0x8f, 0xea,
        0xd1, 0x63, 0x12, 0x0e, 0xf1, 0x2e, 0x6e, 0x06]);
    let proof: [u8; 69] = [
        0x4c, 0x4f, 0xff, 0x51, 0xff, 0x32, 0x2d, 0xe8,
        0xa8, 0x9f, 0xe5, 0x89, 0x98, 0x7f, 0x97, 0x22,
        0x0c, 0xfc, 0xb6, 0x82, 0x0b, 0xd7, 0x98, 0xb3,
        0x1a, 0x0b, 0x56, 0xff, 0xea, 0x22, 0x10, 0x93,
        0xd3, 0x5f, 0x90, 0x9e, 0x58, 0x0b, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00];

    let _builder = SMTBuilder::new();
    let _builder = _builder.insert(&key, &val).unwrap();

    let smt: SMT = _builder.build().unwrap();
    if smt.verify(&root_hash, &proof).is_ok() {
        return Err(Error::VerifyError);
    }

    Ok(())
}

pub fn main() -> Result<(), Error> {
    let ret = _test_verify();
    if ret.is_err() {
        return ret;
    }
    
    let ret = _test_verify_fail();
    if ret.is_err() {
        return ret;
    }

    Ok(())
}

